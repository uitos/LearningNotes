8.使用MySQL中的索引需要注意什么？
9.数据库的左连接和右连接有什么区别？
10.ArrayList与LinkedList有什么区别？
1.自我介绍，介绍项目做了什么
2.JAVA集合框架有哪些
3.ArrayList和LinkedLIst区别
4.ArrayList扩容
4.HashSet方法怎么实现的
5.HashSet怎么检查重复
6.HashMap底层数据结构
7.Spring和SpringBoot有什么区别
8.Bean的生命周期
9.IOC和AOP概念
10.Interceptor和Filter区别
10.MyBatis接口实现原理
11.JVM运行时数据区域
12.对象创建过程
13.对象内存布局
14.线程怎么创建
15.线程池重要参数
16.MySQL索引有哪些
17.回表是什么意思
18.MyISAM和InnoDB区别
19.创建表应该怎么设计字段
20.联合索引的最左匹配原则
21.MVCC实现原理
22.SpringBoot怎么解决循环依赖的

+ String、StringBuffer、StringBuilder  有什么区别？

String是一个引用数据类型,他是不可变的,当我们操作String时,他只会创建新的String对象 这样当我们需要大量操作字符串时 那么必然会创建许多新的对象,会导致性能底下,也会消耗空间,


所以java推出了StringBuilder这个可变的字符串类型,sb继承了abstractStringbulider 他的底层和String一样都定义了一个byte[]类型的数组,不过string的byte数组是被private final修饰的 而asb没有所以sb是可变的字符串,stringbuild提供了一系列操作字符串的方法,比如append()方法,不过这些操作方法改变的都是他自身的数据 ,返回的对象也都是sb对象本身,所以这样就可以进行链式调用,这样我们频繁的修改字符串就方便了很多,实际上在用string拼接时 其底层会创建一个sb并调用sb的append()方法,所以当需要频繁操作字符串时要优先使用sb 但是sb对象也有缺点,因为他是一个可变对象 所以他的线程就会不安全 ,那为了解决这个线程安全问题 


java推出了stringBuffer 这个对象也是继承了abs所以他也能修改字符串,但是跟sb不同的是他使用了synchronized关键字修饰了字符串的操作方法,来保证线程安全,但是因为他每次操作字符串时都会加锁所以会导致性能比较底下


所以String StringBuilder StringBufferd三者的区别和使用场景是


String 不可变,线程安全 当我们对字符串操作较少或者不需要操作时使用String


sb 可变 线程不安全 当我们需要大量操作字符串并且不考虑线程安全是推荐sb

stringbufferd 可变 线程安全,性能底下 当我们需要大量操作并且要保证线程安全的情况下,推荐使用stringBufferd

+ 怎么比较两个字符串的值一样，怎么比较两个字符串是否同一对象？

比较两个字符串值一样需要用equals


比较两个字符串是否是同一对象时,要用==


==比较基本数据类型时比较的是值,比较引用数据类型时比较的是对象的地址值,而字符串是引用数据类型 所以可以用来比较两个字符串是否为同一个对象


要特别注意字符串的创建方式，因为通过字面量创建的字符串可能会引用常量池中的同一个对象，而通过`new`创建的字符串则总是新的对象。


equals用来比较两个字符串啊的值是否一样,他是Object父类中的方法 所以每个类都可以重写这个方法 如果没有重写该方法那么他跟==作用是一样的,String中重写了equals方法所以我们可以用equals方法比较字符串的值,


用equals方法要注意空指针异常,所以我们在比较时要把可能为null的对象放在后面,把不会为null的对象放在前面,如果两个对象都可能为null,就可以用javautils包下的Objects工具类来进行equals比较,equals还有一个隐蔽的坑他不能比较基本数据类型,在比较包装类时 包装类中重写了equals方法 他会先判断是否是同一类型的 比如你包装类型是lang 你很自然在后面比较一个数值,而java中的整型默认为int类型自动装箱为integer类型后,与lang类型不一样,此时虽然数值一样 但是还是会返回false



+ switch 中可以使用 String 吗？

Switch中使用String需要注意一下几点:

**在 Java 7之前，实现基于字符串的条件流的唯一方法是使用 if-else 条件。 但是 Java 7也改进了 switch case 来支持 String。**

1.switch能够取代 if-else-if条件链使得代码更加简洁易读
2.switch比较的时候区分大小写,输出的例子也说明了这一点
3.Java中switch是通过String.equals 方法来比较传递值和case值，所以请确保添加 NULL 检查以避免 NullPointerException
4.java 编译器为 Switch 语句中的字符串生成比链式 if-else-if 条件语句更有效的字节码
5.Java switch case String只能在Java7或更高的版本中使用，否则它会抛出异常



+ String str = new String("abc");创建了几个对象，为什么？



ArrayList  和 LinkedList 的底层数据结构是什么？

ArrayList  默认大小是多少，是如何扩容的？为什么按照1.5倍进行扩容?

> ArrayList和LinkedList是Java集合框架中List接口的两个实现类，也是我们经常使用集合类
>
> **LinkedList**
>
> LinkedList：底层使用一个Node数据结构的双向链表实现，每一个Node节点都包含前一个节点（prev） 的指向和后一个元素节点（next）的引用。
>
> 另外，LinkedList没有初始化大小，也不需要扩容的机制，因为链表不要求存储空间连续，而且它可以通过在链表的头部或尾部添加新节点来扩展
>
> **ArrayList**
>
> ArrayList：底层是Object类型的数组实现，默认情况数组的初始长度为0，当第一次调用add()方法后，数组长度赋值为10，
>
> 也可以在创建ArrayList对象时候指定初始长度，随着不断的往ArrayList里添加数据，当添加的数据达到十个的时候，ArrayList就没有足够的容量去存储后续的数据，那么这个时候，ArrayList会触发自动扩容。
>
> 扩容的流程就是，首先创建一个新的数组，这个数组的长度是原来数组长度的1.5倍取整，然后使用Arrays.copyOf()方法把老数组里面数据拷贝到新的数组里面，扩容完成以后，再把当前需要添加的数据加入到新数组里面，从而完成动态扩容这样一个过程
>
> 另外，为什么按照1.5倍扩容因子扩容，因为扩容因子最适合的范围为(1, 2)，而且1.5倍可以充分利用移位操作，减少浮点数或者运算时间和运算次数。 
>
> **有什么区别**
>
> 1. 内部实现不同。ArrayList 是使用数组的实现，通过索引来访问元素，支持快速随机访问。LinkedList 内部使用双向链表来实现，每个元素都包含对前一个元素和后一个元素的引用，适合插入和删除操作。 
> 2. 数据访问的时间复杂度不同。ArrayList 由于使用数组的实现，它的时间复杂度是O(1)，即常量复杂度。LinkedList 需要从头部或者尾部开始遍历链表，知道找到目标元素的位置，它的时间复杂度是O(n)。 
> 3. 空间占用不同。ArrayList 使用数组来存储数据，所以占用的空间是连续的。LinkedList 使用链表来访问元素，每个元素都包含对前一个元素和后一个元素的引用，占用的空间相对比较大。
>
> 以上就是我对这个问题的理解











> **ArrayList**
>
> 底层数据结构：动态数组。
>
> Object类型的数组
>
> 可以随机访问。 实现RandomAccess接口
>
> 插入和删除性能较差。
>
> 空间连续;查找容易,增删难
>
> **LinkedList**
>
> 底层数据结构：双向链表。
>
> 插入和删除性能好。
>
> 不能随机访问. 访问要遍历
>
> 空间按需;查找难增删容易
>
> **有什么区别**
>
> 1. 内部实现不同。ArrayList 是使用数组的实现，通过索引来访问元素，支持快速随机访问。LinkedList 内部使用双向链表来实现，每个元素都包含对前一个元素和后一个元素的引用，适合插入和删除操作。 
> 2. 数据访问的时间复杂度不同。ArrayList 由于使用数组的实现，它的时间复杂度是O(1)，即常量复杂度。LinkedList 需要从头部或者尾部开始遍历链表，知道找到目标元素的位置，它的时间复杂度是O(n)。 
> 3. 空间占用不同。ArrayList 使用数组来存储数据，所以占用的空间是连续的。LinkedList 使用链表来访问元素，每个元素都包含对前一个元素和后一个元素的引用，占用的空间相对比较大。
>

+ 

  

+ ArrayList  默认大小是多少，是如何扩容的？为什么按照1.5倍进行扩容?

创建时默认大小为0,添加一个元素后大小变为10
当向ArrayList添加元素时，如果当前数组已满，ArrayList会创建一个新的更大的数组，并将旧数组的所有元素复制到新数组中。
扩容后的数组大小通常是原数组大小的1.5倍。
理想分配方案是是在第N次resize()的时候能复用之前N-1次释放的内存，但选择两倍的增长比如像这样：1，2，4，8，16，32，...
可以看到到第三次resize(4)的时候，前面释放的总和只有1+2=3，到第四次resize(8)的时候前面释放的总和只有1+2+4=7，每次需要申请的空间都无法用到前面释放的内存。这样对cache和MMU都不够友好。
为什么是1.5，而不是1.2，1.25，1.8或者1.75？
因为1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。